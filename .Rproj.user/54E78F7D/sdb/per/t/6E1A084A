{
    "collab_server" : "",
    "contents" : "#' Load the data (MeDIP-seq, MRE-seq) and generate corresponding features.\n#'\n#' @param ref_gene_path Path of the reference gene file, which is a bed file with 3 columns (chr, start, end) specifying the CpG sites under analysis.\n#' @param medip1_path Path of the MeDIP-seq data for the first sample.\n#' @param medip2_path Path of the MeDIP-seq data for the second sample.\n#' @param mre1_path Path of the MRE-seq data for the first sample.\n#' @param mre2_path Path of the MRE-seq data for the second sample.\n#'\n#' @return Data matrix containing squencing data features and genomic features, ready to be fitted into CRF model.\n#'\n#' @export\nload_data <- function(ref_gene_path, medip1_path, medip2_path, mre1_path, mre2_path) {\n  print('Loading data and generate features. This may take a while...')\n\n  n_cluster = 8000\n\n  all = read.table(ref_gene_path, header = F)\n  colnames(all) = c('chr', 'start', 'end')\n  gr_ref_gene = GenomicRanges::GRanges(all[,1], ranges = IRanges::IRanges(start = all[,2], end = all[,3]))\n\n  data_paths = c(medip1_path, medip2_path, mre1_path, mre2_path)\n  names = c('medip1', 'medip2', 'mre1', 'mre2')\n  for(i in 1:4) {\n    raw_data = read.table(data_paths[i], header = F)\n    if (i < 3) {\n      gr_raw_data = GenomicRanges::GRanges(raw_data[,1], ranges = IRanges::IRanges(\n        start = raw_data[,2], end = raw_data[,3]))\n    } else {\n      gr_raw_data = GenomicRanges::GRanges(raw_data[,1], ranges = IRanges::IRanges(\n        start = raw_data[,2], end = raw_data[,2] + 2))\n    }\n    count = GenomicRanges::countOverlaps(gr_ref_gene, gr_raw_data)\n    all[,names[i]] = count\n  }\n\n  for(window_size in c(1,10,50,200,1000)) {\n    medip1 = local_smooth(all$medip1, window_size)\n    medip2 = local_smooth(all$medip2, window_size)\n    mre1 = local_smooth(all$mre1, window_size)\n    mre2 = local_smooth(all$mre2, window_size)\n\n    medip1 = medip1 / quantile(medip1[which(medip1>0)], 0.75) * 10\n    medip2 = medip2 / quantile(medip2[which(medip2>0)], 0.75) * 10\n    mre1 = mre1 / quantile(mre1[which(mre1>0)], 0.75) * 10\n    mre2 = mre2 / quantile(mre2[which(mre2>0)], 0.75) * 10\n\n    ratio_medip = abs(medip1 - medip2) / min(medip1 + 1, medip2 + 1)\n    ratio_mre = abs(mre1 - mre2) / min(mre1 + 1, mre2 + 1)\n    dif_combine = abs((medip1+1)*(mre2+1) - (medip2+1)*(mre1+1))\n\n    ratio_medip = infotheo::discretize(ratio_medip, disc = 'equalfreq', nbins = n_cluster)\n    ratio_mre = infotheo::discretize(ratio_mre, disc = 'equalfreq', nbins = n_cluster)\n    dif_combine = infotheo::discretize(dif_combine, disc = 'equalfreq', nbins = n_cluster)\n\n    all[,paste('ratio_medip_', window_size, sep='')] = ratio_medip\n    all[,paste('ratio_mre_', window_size, sep='')] = ratio_mre\n    all[,paste('dif_combine_', window_size, sep='')] = dif_combine\n  }\n\n  all[,'dist'] = all$start - c(all$start[1], all$start[1:nrow(all)-1])\n  all[,'dist'] = infotheo::discretize(all$dist, disc = 'equalfreq', nbins = n_cluster)\n\n  names = c('cpgi', 'exon', 'intron', 'utr3', 'utr5', 'rmsk_DNA', 'rmsk_LINE', 'rmsk_LowSimple', 'rmsk_SINE', 'rmsk_other')\n\n  for(i in 1:10) {\n    gr_genFeature = GenomicRanges::GRanges(genFeatures[[i]][,1], ranges = IRanges::IRanges(\n      start = genFeatures[[i]][,2], end = genFeatures[[i]][,3]))\n    count = GenomicRanges::countOverlaps(gr_ref_gene, gr_genFeature)\n    all[,names[i]] = count\n  }\n  return(all)\n}\n\n\n\n",
    "created" : 1523848867457.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "496819509",
    "id" : "6E1A084A",
    "lastKnownWriteTime" : 1523910214,
    "last_content_update" : 1523910214479,
    "path" : "~/Documents/Paper3/Rcode/Rpackage/LISdmr/R/load_data.R",
    "project_path" : "R/load_data.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}